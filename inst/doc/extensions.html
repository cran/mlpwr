<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Extensions</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Extensions</h1>


<div id="TOC">
<ul>
<li><a href="#beyond-power-analysis" id="toc-beyond-power-analysis">Beyond Power Analysis</a>
<ul>
<li><a href="#sensitivity-analysis" id="toc-sensitivity-analysis">Sensitivity Analysis</a></li>
<li><a href="#compromise-analysis" id="toc-compromise-analysis">Compromise Analysis</a></li>
</ul></li>
<li><a href="#inhomogeneous-cost-functions" id="toc-inhomogeneous-cost-functions">Inhomogeneous Cost
Functions</a></li>
<li><a href="#dimensional-designs" id="toc-dimensional-designs">3-Dimensional Designs</a></li>
</ul>
</div>

<p>We present some extensions to the package. These aim to demonstrate
additional functionality of the package which has not yet been subject
to extensive testing.</p>
<p>Since the Monte Carlo simulations required to generate the results
can be time-consuming, we have precomputed them and included them as a
data file in the package. This enables a quick overview of the methods
without having to rerun the simulations. Below, we load the precomputed
results using the <code>data()</code> function. We also provide the code
used to generate these results later in this vignette.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">data</span>(extensions_results)</span></code></pre></div>
<div id="beyond-power-analysis" class="section level1">
<h1>Beyond Power Analysis</h1>
<p>Here, we demonstrate two other application scenarios, sensitivity
analysis and compromise analysis.</p>
<div id="sensitivity-analysis" class="section level2">
<h2>Sensitivity Analysis</h2>
<p>Sensitivity analysis involves fixing the sample size, desired power,
and alpha level, and determining the effect size that can be detected
with the desired power. We demonstrate this functionality using a
t-test.</p>
<p>The fixed parameters are the sample size N, the alpha level, and the
goal power. We want to determine the corresponding effect size:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="fl">0.01</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>goal_power <span class="ot">&lt;-</span> <span class="fl">0.95</span></span></code></pre></div>
<p>We define our simulation function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>simfun_sensitivity <span class="ot">&lt;-</span> <span class="cf">function</span>(esize) {</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>    <span class="co"># Generate a data set</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n =</span> N, <span class="at">mean =</span> esize)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="co"># Test the hypothesis</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    res <span class="ot">&lt;-</span> <span class="fu">t.test</span>(dat)</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    res<span class="sc">$</span>p.value <span class="sc">&lt;</span> alpha</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>}</span></code></pre></div>
<p>We can find the corresponding effect size using:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Effect Size Finding res1 &lt;- find.design(simfun</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="co"># = simfun_sensitivity, boundaries =</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># c(0,1),integer=FALSE, power =</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co"># goal_power,surrogate = &#39;gpr&#39;,evaluations=8000)</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>res1 <span class="ot">&lt;-</span> extensions_results[[<span class="dv">1</span>]]</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="fu">summary</span>(res1)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt; find.design(simfun = simfun_sensitivity, boundaries = c(0, 1), </span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt;     power = goal_power, evaluations = 8000, surrogate = &quot;gpr&quot;, </span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt;     integer = FALSE)</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt; Design: esize = 0.431758284218821</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="co">#&gt; Power: 0.95127,  SE: 0.0028</span></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="co">#&gt; Evaluations: 8000,  Time: 26.02,  Updates: 16</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a><span class="co">#&gt; Surrogate: Gaussian process regression</span></span></code></pre></div>
<p>This leads us to an effect size of about 0.43, as measured by Cohen’s
d. To confirm the correctness of this result, we check it analytically
using the pwr package.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">library</span>(pwr)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>esize_correct <span class="ot">&lt;-</span> <span class="fu">pwr.t.test</span>(<span class="at">n =</span> N, <span class="at">sig.level =</span> alpha,</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="at">power =</span> goal_power, <span class="at">type =</span> <span class="st">&quot;one.sample&quot;</span>)<span class="sc">$</span>d</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>esize_correct</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt; [1] 0.4293178</span></span></code></pre></div>
<p>The analytical result is very close to the result obtained with
mlpwr. With a small simulation study, we further confirm that the
analytical result is correct.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">replicate</span>(<span class="dv">10000</span>, <span class="fu">simfun_sensitivity</span>(esize_correct))</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">mean</span>(a)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">#&gt; [1] 0.9521</span></span></code></pre></div>
</div>
<div id="compromise-analysis" class="section level2">
<h2>Compromise Analysis</h2>
<p>In compromise analysis, the sample size and effect size are fixed in
the DGF, and the goal is to find a decision criterion that optimizes the
desired ratio of alpha and beta errors. Again, we demonstrate this
functionality using a t-test scenario.</p>
<p>The fixed parameters are the sample size N, the effect size (given by
Cohen’s d) and the desired ratio of the alpha and beta errors:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>esize <span class="ot">&lt;-</span> <span class="fl">0.3</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>desired_ratio <span class="ot">&lt;-</span> <span class="dv">1</span></span></code></pre></div>
<p>We now define our simulation function. Its argument is a given
threshold for the test statistic. This function then generates two data
sets - one under the null, one under the alternative hypothesis - and
evaluates whether the use of this threshold leads to a Type I error (for
the data set generated under the null hypothesis) or a Type II error
(for the data set generated under the alternative hypothesis).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>simfun_compromise <span class="ot">&lt;-</span> <span class="cf">function</span>(crit) {</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    <span class="co"># Generate a data set</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n =</span> N, <span class="at">mean =</span> <span class="dv">0</span>)</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>    <span class="co"># Test the hypothesis</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>    res <span class="ot">&lt;-</span> <span class="fu">t.test</span>(dat)</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>    a <span class="ot">&lt;-</span> res<span class="sc">$</span>statistic <span class="sc">&gt;</span> crit</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>    <span class="co"># Generate a data set</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n =</span> N, <span class="at">mean =</span> esize)</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>    <span class="co"># Test the hypothesis</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>    res <span class="ot">&lt;-</span> <span class="fu">t.test</span>(dat)</span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>    b <span class="ot">&lt;-</span> res<span class="sc">$</span>statistic <span class="sc">&lt;</span> crit</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">c</span>(a, b))</span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>}</span></code></pre></div>
<p>We run this function one to see how the output looks - TRUE indicates
that a Type I (1st entry) or Type II error (2nd entry) was observed:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">simfun_compromise</span>(<span class="fl">0.1</span>)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="co">#&gt;     t     t </span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="co">#&gt; FALSE FALSE</span></span></code></pre></div>
<p>However, we are not interested in the Type I and Type II errors
themselves, but in their ratio. We therefore need to define a function
that organizes how the individual simulations are aggregated:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>aggregate_fun <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    y <span class="ot">&lt;-</span> <span class="fu">rowMeans</span>(<span class="fu">matrix</span>(x, <span class="at">nrow =</span> <span class="dv">2</span>))</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>    y[<span class="dv">2</span>]<span class="sc">/</span>y[<span class="dv">1</span>]</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>}</span></code></pre></div>
<p>We can find the optimal decision criterion for reaching the desired
ratio of alpha and beta errors using:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># res2 &lt;- find.design(simfun = simfun_compromise,</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="co"># boundaries = c(1,2), power =</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co"># desired_ratio,integer = FALSE, aggregate_fun =</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co"># aggregate_fun,surrogate=&#39;svr&#39;,use_noise=FALSE,evaluations=8000)</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>res2 <span class="ot">&lt;-</span> extensions_results[[<span class="dv">2</span>]]</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="fu">summary</span>(res2)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co">#&gt; find.design(simfun = simfun_compromise, boundaries = c(1, 2), </span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a><span class="co">#&gt;     power = desired_ratio, evaluations = 8000, surrogate = &quot;svr&quot;, </span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a><span class="co">#&gt;     aggregate_fun = aggregate_fun, integer = FALSE, use_noise = FALSE)</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a><span class="co">#&gt; Design: crit = 1.48455055391577</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a><span class="co">#&gt; Power: 1.00086,  SE: NA</span></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a><span class="co">#&gt; Evaluations: 8000,  Time: 6.89,  Updates: 6</span></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a><span class="co">#&gt; Surrogate: Support vector regression</span></span></code></pre></div>
<p>The analysis with mlpwr leads to a desired threshold of about 1.48.
The ratio of Type I and Type II errors is given as “power” in this
output and close to the desired value of 1.</p>
<p>Note that we used some additional arguments in this case. The
‘integer’ argument tells the algorithm whether to look for integer
design parameters - this is set to ‘FALSE’ for our case of effect sizes.
The ‘use_noise=FALSE’ indicates that we do not account for the Monte
Carlo error at each design parameter. This functionality can be added in
the future. Note also that we use ‘power’ as an argument to the
find.design function and in the output of summary(res2) to indicate the
desired ratio of alpha and beta error. This is a makeshift solution and
we consider rewording this argument to ‘goal’ in the future.</p>
<p>To check the correctness of our result, we compare it with an
analytical solution obtained from the t-distribution and an numerical
optimizer:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>fun <span class="ot">&lt;-</span> \(alpha) {</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    beta <span class="ot">&lt;-</span> alpha <span class="sc">*</span> desired_ratio</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>    <span class="fu">abs</span>(<span class="fu">qt</span>(<span class="dv">1</span> <span class="sc">-</span> alpha, <span class="at">ncp =</span> <span class="dv">0</span>, <span class="at">df =</span> N <span class="sc">-</span> <span class="dv">1</span>)  <span class="co"># crit for alpha</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a> <span class="sc">-</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>        <span class="fu">qt</span>(beta, <span class="at">ncp =</span> esize <span class="sc">*</span> <span class="fu">sqrt</span>(N), <span class="at">df =</span> N <span class="sc">-</span> <span class="dv">1</span>)  <span class="co"># crit for beta</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>)</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>}</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="fu">optim</span>(<span class="fl">0.1</span>, fun, <span class="at">lower =</span> <span class="fl">1e-09</span>, <span class="at">upper =</span> <span class="dv">1</span> <span class="sc">-</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>    <span class="fl">1e-09</span>, <span class="at">method =</span> <span class="st">&quot;L-BFGS-B&quot;</span>)<span class="sc">$</span>par</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>crit <span class="ot">&lt;-</span> <span class="fu">qt</span>(<span class="dv">1</span> <span class="sc">-</span> alpha, <span class="at">ncp =</span> <span class="dv">0</span>, <span class="at">df =</span> N <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>crit</span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a><span class="co">#&gt; [1] 1.503731</span></span></code></pre></div>
<p>This leads to a threshold of about 1.50, which is very close to the
solution of mlpwr. Using simulations, we can show that the analytical
solution is indeed correct:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">replicate</span>(<span class="dv">10000</span>, <span class="fu">simfun_compromise</span>(crit))</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="fu">aggregate_fun</span>(a)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">#&gt; [1] 0.992515</span></span></code></pre></div>
</div>
</div>
<div id="inhomogeneous-cost-functions" class="section level1">
<h1>Inhomogeneous Cost Functions</h1>
<p>Some uses cases feature more complex cost functions. We cover an
example here. It builds on the “ANOVA” simulation function in the
“simulation_functions” vignette.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>simfun_anova <span class="ot">&lt;-</span> <span class="cf">function</span>(n, n.groups) {</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>    <span class="co"># Generate a data set</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    groupmeans <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n.groups, <span class="at">sd =</span> <span class="fl">0.2</span>)  <span class="co"># generate groupmeans using cohen&#39;s f=.2</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">sapply</span>(groupmeans, <span class="cf">function</span>(x) <span class="fu">rnorm</span>(n,</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>        <span class="at">mean =</span> x, <span class="at">sd =</span> <span class="dv">1</span>))  <span class="co"># generate data</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> dat <span class="sc">|&gt;</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>        <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>        <span class="fu">gather</span>()  <span class="co"># format</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>    <span class="co"># Test the hypothesis</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>    res <span class="ot">&lt;-</span> <span class="fu">aov</span>(value <span class="sc">~</span> key, <span class="at">data =</span> dat)  <span class="co"># perform ANOVA</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>    <span class="fu">summary</span>(res)[[<span class="dv">1</span>]][<span class="dv">1</span>, <span class="dv">5</span>] <span class="sc">&lt;</span> <span class="fl">0.01</span>  <span class="co"># extract significance</span></span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a>}</span></code></pre></div>
<p>We assume that there are different costs for different clusters. We
assume that the costs per cluster is cheaper if there is only a small
number of clusters. Adding additional clusters gets increasingly
expensive (for example, because assessing a large number of groups is
more costly).</p>
<p>Specifically, we assume that the first five clusters cost 10, the
next five cost 15, the next five cost 20, and so on.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>prices <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">10</span>, <span class="dv">5</span>), <span class="fu">rep</span>(<span class="dv">15</span>, <span class="dv">5</span>), <span class="fu">rep</span>(<span class="dv">20</span>, <span class="dv">5</span>), <span class="fu">rep</span>(<span class="dv">25</span>,</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>    <span class="dv">5</span>), <span class="fu">rep</span>(<span class="dv">30</span>, <span class="dv">5</span>), <span class="fu">rep</span>(<span class="dv">35</span>, <span class="dv">5</span>), <span class="fu">rep</span>(<span class="dv">40</span>, <span class="dv">5</span>))</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>costfun <span class="ot">&lt;-</span> <span class="cf">function</span>(n, n.groups) {</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>    <span class="dv">5</span> <span class="sc">*</span> n <span class="sc">+</span> n.groups <span class="sc">*</span> <span class="fu">sum</span>(prices[<span class="dv">1</span><span class="sc">:</span>n.groups])</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>}</span></code></pre></div>
<p>We can now find a good design using:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="co"># res3 &lt;- find.design( simfun = simfun_anova,</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="co"># costfun = costfun, boundaries = list(n = c(10,</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co"># 150), n.groups = c(5, 30)), power = .95 )</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>res3 <span class="ot">&lt;-</span> extensions_results[[<span class="dv">3</span>]]</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="fu">summary</span>(res3)</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#&gt; find.design(simfun = simfun_anova, boundaries = list(n = c(10, </span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="co">#&gt;     150), n.groups = c(5, 30)), power = 0.95, costfun = costfun)</span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a><span class="co">#&gt; Design: n = 135, n.groups = 10</span></span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a><span class="co">#&gt; Power: 0.95017,  SE: 0.00584,  Cost: 1925</span></span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a><span class="co">#&gt; Evaluations: 4000,  Time: 13.6,  Updates: 32</span></span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a><span class="co">#&gt; Surrogate: Gaussian process regression</span></span></code></pre></div>
<p>The proposed solution contains 10 groups and 135 participants per
group.</p>
</div>
<div id="dimensional-designs" class="section level1">
<h1>3-Dimensional Designs</h1>
<p>As an example for a study design with more than 2 dimensions, we
consider a multilevel design with the three dimensions:</p>
<ul>
<li>Number of schools</li>
<li>Number of students per school</li>
<li>Number of observations per student</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">library</span>(lme4)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="fu">library</span>(lmerTest)</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>simfun_3d <span class="ot">&lt;-</span> <span class="cf">function</span>(n.per.school, n.schools, n.obs) {</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>    <span class="co"># generate data</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>    school <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>n.schools, <span class="at">each =</span> n.per.school <span class="sc">*</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>        n.obs)</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>    student <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(n.schools <span class="sc">*</span> n.per.school), <span class="at">each =</span> n.obs)</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a>    pred <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">&quot;old&quot;</span>, <span class="st">&quot;new&quot;</span>), n.per.school <span class="sc">*</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a>        n.schools <span class="sc">*</span> n.obs, <span class="at">each =</span> n.obs), <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">&quot;old&quot;</span>,</span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a>        <span class="st">&quot;new&quot;</span>))</span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">school =</span> school, <span class="at">student =</span> student,</span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a>        <span class="at">pred =</span> pred)</span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a>    params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">theta =</span> <span class="fu">c</span>(<span class="fl">0.5</span>, <span class="dv">0</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>), <span class="at">beta =</span> <span class="fu">c</span>(<span class="dv">0</span>,</span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a>        <span class="dv">1</span>), <span class="at">sigma =</span> <span class="fl">1.5</span>)</span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a>    <span class="fu">names</span>(params<span class="sc">$</span>theta) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;school.(Intercept)&quot;</span>,</span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a>        <span class="st">&quot;school.prednew.(Intercept)&quot;</span>, <span class="st">&quot;school.prednew&quot;</span>,</span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a>        <span class="st">&quot;student.(Intercept)&quot;</span>)</span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a>    <span class="fu">names</span>(params<span class="sc">$</span>beta) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;(Intercept)&quot;</span>, <span class="st">&quot;prednew&quot;</span>)</span>
<span id="cb18-19"><a href="#cb18-19" tabindex="-1"></a>    dat<span class="sc">$</span>y <span class="ot">&lt;-</span> <span class="fu">simulate.formula</span>(<span class="sc">~</span>pred <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">+</span> pred <span class="sc">|</span> school) <span class="sc">+</span></span>
<span id="cb18-20"><a href="#cb18-20" tabindex="-1"></a>        (<span class="dv">1</span> <span class="sc">|</span> student), <span class="at">newdata =</span> dat, <span class="at">newparams =</span> params)[[<span class="dv">1</span>]]</span>
<span id="cb18-21"><a href="#cb18-21" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" tabindex="-1"></a>    <span class="co"># test hypothesis</span></span>
<span id="cb18-23"><a href="#cb18-23" tabindex="-1"></a>    mod <span class="ot">&lt;-</span> <span class="fu">lmer</span>(y <span class="sc">~</span> pred <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">+</span> pred <span class="sc">|</span> school) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span></span>
<span id="cb18-24"><a href="#cb18-24" tabindex="-1"></a>        student), <span class="at">data =</span> dat)</span>
<span id="cb18-25"><a href="#cb18-25" tabindex="-1"></a>    pvalue <span class="ot">&lt;-</span> <span class="fu">summary</span>(mod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="dv">2</span>, <span class="st">&quot;Pr(&gt;|t|)&quot;</span>]</span>
<span id="cb18-26"><a href="#cb18-26" tabindex="-1"></a>    pvalue <span class="sc">&lt;</span> <span class="fl">0.01</span></span>
<span id="cb18-27"><a href="#cb18-27" tabindex="-1"></a>}</span>
<span id="cb18-28"><a href="#cb18-28" tabindex="-1"></a></span>
<span id="cb18-29"><a href="#cb18-29" tabindex="-1"></a>costfun_3d <span class="ot">&lt;-</span> <span class="cf">function</span>(n.per.school, n.schools, n.obs) {</span>
<span id="cb18-30"><a href="#cb18-30" tabindex="-1"></a>    <span class="dv">100</span> <span class="sc">*</span> n.per.school <span class="sc">+</span> <span class="dv">200</span> <span class="sc">*</span> n.schools <span class="sc">+</span> <span class="fl">0.1</span> <span class="sc">*</span> n.obs <span class="sc">*</span></span>
<span id="cb18-31"><a href="#cb18-31" tabindex="-1"></a>        n.per.school <span class="sc">*</span> n.schools</span>
<span id="cb18-32"><a href="#cb18-32" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># res4 = find.design(simfun = simfun_3d, costfun</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="co"># = costfun_3d, boundaries = list(n.per.school =</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="co"># c(5, 25), n.schools = c(10, 30), n.obs =</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="co"># c(3,10)), power = .95)</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>res4 <span class="ot">&lt;-</span> extensions_results[[<span class="dv">4</span>]]</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a><span class="fu">summary</span>(res4)</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a><span class="co">#&gt; find.design(simfun = simfun_3d, boundaries = list(n.per.school = c(5, </span></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a><span class="co">#&gt;     25), n.schools = c(10, 30), n.obs = c(3, 10)), power = 0.95, </span></span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a><span class="co">#&gt;     costfun = costfun_3d)</span></span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a><span class="co">#&gt; Design: n.per.school = 15, n.schools = 15, n.obs = 3</span></span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a><span class="co">#&gt; Power: 0.96948,  SE: 0.00374,  Cost: 4567.5</span></span>
<span id="cb19-16"><a href="#cb19-16" tabindex="-1"></a><span class="co">#&gt; Evaluations: 4020,  Time: 2237.39,  Updates: 48</span></span>
<span id="cb19-17"><a href="#cb19-17" tabindex="-1"></a><span class="co">#&gt; Surrogate: Gaussian process regression</span></span></code></pre></div>
<p>In this case, going with the minimum number of observations per
student seems to be the ideal choice.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
